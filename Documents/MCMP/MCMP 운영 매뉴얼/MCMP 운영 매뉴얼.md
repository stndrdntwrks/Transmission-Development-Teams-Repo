
| 프로젝트명 | 차세대 메시지 메시지 전송 플랫폼 개선 개발 |       |            |
| ----- | ------------------------ | ----- | ---------- |
| 문서명   | MCMP 운영 메뉴얼              | 버전    | 1.0.0      |
| 소속    | 전송 개발팀                   | 작성일   | 2024-07-04 |
| 작성자   | 장정호                      | 최종수정일 |            |
| 문서 번호 |                          |       |            |

---

# 목차

1. 차세대 메시지 전송 플랫폼
    1. MCMP가 사용하는 REDIS와 RABBITMQ
    2. 클러스터란?
    3. MCMP 개요
2. OIS에서의 운영 및 관리
    1. OIS 개요
    2. 고객 운영 관리
    3. Sender 운영 관리
    4. Routing 운영 관리
3. 모니터링 시스템
    1. Pin Point
    2. Ois에서의 Agent Managent

## 시작하며

이 문서는 차세대 메시지 전송 플랫폼에 작성된 어플리케이션 (**이하 MCMP**)을 운영하는데 필요한 공통 지식을 제공한다.

차세대 메시징 전송 플랫폼이 레거시보다 성능이나 자동화 부분 등 에서 이점이 있는 것은 사실이지만, 새로운 기술과 설계의 방식에서 기존의 레거시보다 복잡해진 것은 분명한 사실이다.

아쉽지만, 회사에 입사한 운영자가 처음 플랫폼을 보고 이 문서만을 통해 플랫폼 전체를 이해하기란 어려울 것 같지만, 본 문서가 그러한 독자에게 조금이나마 도움이 되었으면 한다.

---

# 1. 차세대 메시지 전송 플랫폼

### MCMP가 사용하는 Redis와 Rabbitmq

MCMP는 대규모 분산 처리 시스템이다, MSA의 단점에 나와있듯 대규모 분산 처리 시스템에는 서비스간의 통신이 필요한데, MCMP는 서로 간의 통신 매개체를 Rabbitmq와 Redis를 사용한다, Rabbitmq를 통해 MCMP는 비동기 처리를 할 수있다. 또, Redis와 Rabbitmq를 사용하여 마이크로 서비스 단위의 결합도를 낮춘다.

쉽게 말해서 각 **Application 서로 간의 의존성과 결합성을 낮춰 각 마이크로 서비스 단위의 독립적인 역할**만 담당 할 수 있도록 도와준다. MCMP는 Redis와 Rabbitmq를 Cluster 환경을 구성하여 사용하고 있다. 위 본문에서 설명 하듯 **MCMP에게 Redis와 Rabbitmq는 혈관과 같은 중요한 역할**을 담당한다.

본 장에서는 MCMP가 주로 사용하는 REDIS와 RABBITMQ에대한 설명을 하겠다.

![[Redis Logo.png]]

### Redis란?

**Redis**(Remote Dictionary Server)는 **고성능 키-값 저장소**로서, **메모리 내 데이터 구조 서버**이다. Redis는 **인메모리 데이터 저장소**이다. 쉽게 말해서, Redis는 데이터를 컴퓨터의 메모리에 저장하는 일종의 데이터베이스이다. **일반적인 데이터베이스는 데이터를 하드 디스크에 저장**하지만, **Redis는 데이터를 메모리에 저장**하기 때문에 **매우 빠르게 데이터를 읽고 쓸 수 있다**.

Redis는 기본적으로 데이터를 메모리에 저장하여 빠른 읽기와 쓰기를 제공하지만, RDB(Snapshotting) 을 사용하여 **특정 간격으로 메모리**에 있는 **데이터를 영구적으로 저장**하고 **복구할 수 있도록 디스크에 저장**한다. Redis는 설정된 주기마다 전체 데이터 베이스를 스냅샷으로 디스크에 기록하여 **데이터의 영속성을 보장**한다. 단, 마지막 **스냅샷 이후 수정 된 메모리 데이터는 복구 할 수 없다**.

### **클러스터 환경의 Redis를 MCMP에서 공유 메모리로 활용하는 이점**

마이크로서비스 아키텍처(MSA) 환경에서 Redis를 클러스터 모드로 설정하여 공유 메모리로 활용하는 것은 여러 가지 이점을 제공한다. 이는 시스템 성능을 향상시키고, 데이터 일관성을 유지하며, 확장성을 제공하는 데 크게 기여한다.

- **1. 고가용성과 내결함성**

Redis 클러스터 모드는 **데이터를 여러 노드에 분산 저장함**으로써 **단일 노드 장애로부터 시스템을 보호한**다. 이로 인해 **서비스의 가용성이 높아**지고, 하나의 **노드에서 장애가 발생해도 다른 노드가 그 역할을 대신하여 데이터 접근을 유**지할 수 있다.

- **2. 향상된 성능**

**Redis는 인메모리 데이터 저장소**로, 디스크 기반 데이터베이스보다 훨씬 빠른 읽기 및 쓰기 속도를 제공한다. **이는 MSA 환경에서 중요한** **데이터의 빠른 접근과 처리 속도를 보장한**다. 특히, 캐싱 레이어로 활용할 경우 **데이터베이스 조회 빈도를 줄여 전체 시스템 성능을 크게 향상**시킬 수 있다.

- **3. 스케일 아웃(Scale-out) 용이성**

Redis 클러스터는 데이터와 요청을 **여러 노드에 자동으로 분산**시킴으로써 **수평 확장이 가능하다**. 새로운 노드를 추가함으로써 쉽게 클러스터 용량을 확장할 수 있어, **트래픽 증가에도 유연하게 대응**할 수 있다

- **4. 데이터 일관성 유지**

Redis 클러스터는 데이터 분산 및 복제 메커니즘을 통해 일관성을 유지한다. **여러 마이크로서비스가 동일한 데이터를 공유하고 접근**할 때, **데이터의 최신 상태를 보장**할 수 있어 **데이터 일관성 문제를 줄일 수 있다**.

### Redis 접속 정보

레디스 클러스터 서버의 접속 정보

음... 지정되어 있는 레디스 패스워드 정보가 현재 셋팅 되어 있지 않다

개발계

- - password : ""

운영계

- - password : ""

### 구성 되어 있는 서버

구분되어 있듯 3개의 노드에 각각 7000, 7100, 7200 포트로 각각 총 9개의 노드로 구성되어 있다.

|   |   |   |   |   |
|---|---|---|---|---|
|구분|개발계|   |운영계|   |
|node1|220.95.214.5|7000, 7100, 7200|222.233.53.25|7000, 7100, 7200|
|node2|220.95.214.6|7000, 7100, 7200|222.233.53.26|7000, 7100, 7200|
|node3|220.95.214.7|7000, 7100, 7200|222.233.53.27|7000, 7100, 7200|

---

![[RabbitMQ Logo.png]]

### Rabbitmq란?

**Rabbitmq**는 메시지 브로커로 메시지를 생산자에서 소비자로 전달하는 역할을 한다.

이를 통해 시스템 간의 통신을 비동기적으로 처리하고, 메시지 큐를 사용하여 메시지 전달을 보장한다.

![[RabbitMQ 구조.png]]

### 기본적인 Rabbitmq의 동작 원리

- Producer: 요청을 보내는 주체, 보내고자 하는 메세지를 exchange에 publish한다.
- Consumer: producer로부터 메세지를 받아 처리하는 주체
- Exchange: producer로부터 전달받은 메세지를 어떤 queue로 보낼지 결정하는 장소, 4가지 타입이 있음
- Queue: consumer가 메세지를 consume하기 전까지 보관하는 장소
- Binding: Exchange와 Queue의 관계, 보통 사용자가 특정 exchange가 특정 queue를 binding하도록 정의한다. (fanout 타입은 예외)

위 사진의 Message Brocker가 Rabbitmq AMQP Server를 뜻한다.

Exchange의 4가지 타입에 따른 라우팅 전략은 Rabbitmq 공식 문서를 통해 필요하다면 운영자가 공부를 하면 좋을것 같다. 또, 이외 binding의 개념 또한 중급 이상의 운영자라면 따로 공부하여 숙지하면 플랫폼 운영에 도움이 되니, 공부하길 바란다.

### 대규모 분산 처리 시스템에서의 메시지 브로커(Rabbitmq)가 필요한 이유

1. **비동기 통신 지원**: 메시지 브로커는 **비동기 메시지 전송을 지원**하여 **서비스 간의 결합도를 낮춘다**. 이는 **서비스 간의 의존성을 줄이**고, **각 서비스가 독립적**으로 동작할 수 있도록 한다.
2. **확장성**: **대규모 시스템에서는 수많은 요청을 효율적으로 처리**해야 합니다. 메시지 브로커는 다수의 메시지를 안전하게 버퍼링하고 처리할 수 있는 구조를 제공하여 시스템의 확장성을 높인다.
3. **신뢰성과 내구성**: **메시지 브로커는 메시지를 안전하게 보관하고 전달할 수 있어**, 시스템에서 발생할 수 있는 장애나 네트워크 문제에 대비할 수 있다. 메시지는 **일시적인 장애가 발생해도 안전하게 보관되어, 장애 복구 후에도 처리될 수 있다**.
4. **유연한 통합**: 다양한 프로토콜과 통신 방식을 지원하여 **서로 다른 시스템 간의 통합을 용이하다**. 이는 마이크로서비스 아키텍처에서 각 서비스가 사용하는 기술 스택이나 프로토콜에 상관없이 통신할 수 있음을 의미한다.

### 클러스터란?

MCMP를 구성하는 Rabbitmq와 Redis는 모두 클러스터링 되어 있다. 따라서, 운영자는 클러스터라는 개념에 대해서 이해하고 있어야한다.

클러스터(Cluster)란 여러대의 컴퓨터나 서버가 네트워크로 연결되어 하나의 단일 시스템처럼 동작하도록 구성된 환경을 의미한다. 일반적으로 클러스터는 목적에 따라 다양한 서버 또는 컴퓨터의 자원을 통합하여 더 높은 성능, 가용성, 확장성을 제공한다.

### 클러스터의 중요 개념

1. **고가용성과 신뢰성**: 클러스터는 **여러 대의 물리적인 서버를 하나로 묶어서 작동**하기 때문에 하나의 서버에 장애가 발생해도 시스템 전체가 중단되지 않고 계속 운영될 수 있다. 이는 비즈니스 연속성을 유지하고 서비스 가용성을 높이는 데 중요한 역할을 한다.
2. **성능 향상**: 클러스터는 병렬 처리를 통해 더 높은 성능을 제공할 수 있다. 여러 대의 서버가 작업을 분산 처리하므로 처리 속도가 개선되고, 대량의 데이터나 복잡한 계산을 더 효율적으로 처리할 수 있다.
3. **확장성**: 필요에 따라 클러스터는 쉽게 확장할 수 있다. 새로운 서버나 노드를 추가하여 클러스터의 용량을 증가시키거나, 서비스의 요구 사항에 맞춰 구성을 조정할 수 있다.

### Rabbitmq 접속 정보

|   |   |   |
|---|---|---|
|구분|개발계|운영계|
|아이디|admin|admin|
|패스워드|egarreo01!|egarreo01!|

### 구성 되어 있는 서버

|   |   |   |
|---|---|---|
|구분|개발계|운영계|
|노드 1|220.95.214.8 : 5672|222.233.53.29 : 5672|
|노드 2|220.95.214.9 : 5672|222.233.53.30 : 5672|
|노드 3|220.95.214.10 : 5672|222.233.53.31 : 5672|

---

### **1-1 MCMP 개요**

**MCMP**란, **Multi Channel Message Platform** **차세대 메시지 전송 플랫폼 개발 프로젝트**의 프로덕트 명이다, 이름에서 알 수 있듯 다양한 메시지 채널을 동시에 지원 할 수 있는 Platform이며, 구버전의 G/W들에서 발생했던 다양한 장애를 자동화하고, 운영자가 보다 쉽게 Platform을 운영할 수있는 환경을 제공하고, 자유로운 라우팅이 가능캐 하는 것을 목표로 둔다.

플랫폼은 **MSA(Micro Service Architecture)방식**으로 설계 되었다, 기능 서비스 단위로 Application을 분리하여 결합도를 최소화 하였고 각 Application간의 통신은 Message Publisher인 Rabbitmq, Redis를 사용한다.

차세대 메시징 전송 플랫폼(이하 MCMP)은 기존 Standard Networks의 구 STD Agent ,구SMS G/W(C코드로 작성된), 구 MMS G/W, 구 Multi ADT, 구 RCS G/W를 대체하는 프로젝트이다. 향후 해외 발송까지 지원할 예정이다.

현재 (24/06/21기준) 차세대 메시지 전송 플랫폼이 지원하는 Message 채널은 다음과 같다

|   |   |
|---|---|
|채널|가용 가능 여부|
|SMS|O|
|LMS/MMS|O|
|RCS|O|
|KKO|O|
|국제 발송|X|

### 1-2 MSA란?

앞서 설명 한것처럼 **MCMP**는 **MSA**(Micro Service Architecture)방식의 설계를 통해 개발되었다. 운영자는 최소한의 플랫폼을 운영하는데에 필요한 MSA의 개념은 알아둘 필요가 있다.

**Micro Service Architecture**

MSA는 여러 개의 작은 서비스로 구성되어 각 서비스가 독립적으로 개발되고 배포되는 구조이다

MSA로 구성되어 있는 애플리케이션의 경우 전체 시트템이 분산되어 있어 개발, 배포가 독립적으로 가능하며 **확장성**과 **유지관리** 가 용이해진다

**MSA의 장점**

- 서비스 간 독립성으로 인해 **확장성과 유연성이 높아**진다.
- 기능 고립성이라는 특징 때문에 **일부 서비스가 실패**하더라도 **전체 시스템에 큰 영향을 미치지 않는다.**

**MSA의 단점**

- 서비스 간 통신이 필요하며, 서로 간 **연결 구축 및 관리의 복잡성이 증가**한다.
- 초기 개발 및 통신 등에 시간이 소요된다.

**MCMP는 MSA Architecture(대규모 분산 처리 시스템)으로 설계**되었다.

MSA의 장점 중 하나인 일부 서비스가 실패하거나, 장애가 발생하더라도 전체 시스템의 큰 영향을 미치지 않도록 할 수 있게 개발하였다.

그러나, MSA의 단점에 나와있듯 서비스간의 통신이 필요한데, MCMP는 서로간의 통신 매개체를 Rabbitmq와 Redis를 사용한다, Rabbitmq를 통해 MCMP는 비동기 처리를 할 수있다. 또, Redis와 Rabbitmq를 사용하여 마이크로 서비스 단위의 결합도를 낮춘다.

쉽게 말해서 각 Application 마다마다의 의존성과 결합성을 낮춰 각 마이클 서비스 단위의 서비스만 담당 할 수 있도록 도와준다. 중요한 것은 **Redis와 Rabbitmq의 장애**가 발생할 경우 현재로서는 **치명적인 장애가 발생** 할 수 있다. 안정적인 플랫폼 운영되기 위해서는 운영자가 위 **2개 Redis, Rabbitmq Server의 서비스를 잘 관리**해야할 필요가 있다.

MCMP는 플랫폼 내부에서 Message Delivery라는 공통의 프로토콜을 사용한다.

**Message Delivery를 본 문서에서 다루기엔 내용이 너무 많아, Message Delivery 문서에서 자세히 다루겠다.**

아래는 MCMP를 구성하는 Application의 내역이다. 각 Application의 주요 기능을 설명하겠다, **자세한 상세 기능은 각 Application의 업무 기술서**를 참고 바란다.

|   |   |   |   |
|---|---|---|---|
|어플리케이션 명|개발계|운영계|설명|
|Eureka Server|220.95.214.11|222.233.53.43||
|Config Server|220.95.214.11|222.233.53.43||
|OAuth2 Server|220.95.214.11|222.233.53.43||
|API Gate Way Server|220.95.214.12|222.233.53.36||
|Message Server|220.95.214.13|222.233.53.37||
|PTP Server|220.95.214.14|222.233.53.38||
|Router Server|220.95.214.14|222.233.53.38||
|차세대 Sender|220.95.214.17||차세대 Sender 업무 기술서를 참고|
|Reporter Server|220.95.214.15|222.233.53.39, 119.207.74.9||
|Retry Reporter Server|220.95.214.15|222.233.53.39||
|DB Logger Server|220.95.214.11|222.233.53.43||
|Sender Manager Server|220.95.214.11|222.233.53.39||
|Agent Manager Server|220.95.214.15|222.233.53.39||
|Data Manager Server|220.95.214.11|222.233.53.43||
|File Logger Server|220.95.214.11|222.233.53.43||
|OIS (Operate Information System)|222.233.53.16|222.233.53.42||
|차세대 Agent|고객사|고객사|차세대 Agent의 메뉴얼을 참고|

- MCMP 구성 사진
	![[MCMP 구성 이미지.png]]


## 1. Eureka Server

MCMP는 Spring Cloud Frame Work를 사용하여 개발 되었다, Spring Cloud에서 **Eureka Server**는 **서비스 디스커버리**를 제공하는 역할을 담당한다. 이는 마이크로서비스 아키텍처에서 중요한 컴포넌트로, 여러 개의 마이크로서비스가 서로를 동적으로 발견하고 통신할 수 있도록 도와준다.

### 주요 역할

1. **서비스 등록 (Service Registration)**: 각 마이크로서비스는 Eureka Server에 자신을 등록한다. 이 과정에서 마이크로서비스는 자신의 위치(호스트 및 포트), 서비스 이름, 기타 메타데이터 등을 Eureka Server에 전달한다.
2. **서비스 디스커버리 (Service Discovery)**: 클라이언트 서비스 또는 다른 마이크로서비스는 Eureka Server에 등록된 서비스를 검색할 수 있다. 이를 통해 각 서비스의 위치를 동적으로 알아내어 통신할 수 있다.
3. **헬스 체크 (Health Check)**: Eureka Server는 등록된 서비스의 상태를 주기적으로 확인한다 서비스 인스턴스가 정상적으로 작동하는지 확인하고, 비정상 상태인 서비스 인스턴스는 등록 목록에서 제거한다.
   
	![[Eureka Health Check Image.png]]
	
다시말해, Eureka Server는 마이크로서비스의 동적 서비스 디스커버리를 가능하게 하여, 각 서비스가 자신을 등록하고 다른 서비스의 위치를 쉽게 발견할 수 있도록 한다. 이를 통해 마이크로서비스 간의 통신을 효율적으로 관리할 수 있으며, 시스템의 확장성과 유연성을 높일 수 있다.

Eureka Server는 MCMP의 **가장 중요한 서버**이며 이서버가 **장애일 경우 차세대 전송 플랫폼(MCMP) 전체 서버가 장애 상황에 놓여질 수 있으므로**, 각별한 주의가 필요하다.

가능한, Eureka에 대하여 운영자는 공부를 하는 것을 권장한다.

## 2. Config Server

앞서 설명한대로, Spring Cloud Frame work의 Config Frame work를 사용하여 개발되었다.

분산 시스템에서 설정 데이터를 중앙 집중화하여 관리하기 위한 구성 서버이다. 이는 여러 마이크로서비스 Application이 동일한 구성 설정을 사용할 수 있도록 하며, 구성 변경 시 일관성과 신속한 반영을 보장한다.

### 주요 역할

1. **설정 중앙 집중화** Eureka의 Discovery에 instance를 등록한 Application은 Config Server에게 요청하여 본인의 설정 파일을 받아간다.

## 3. OAuth2 Server

MCMP의 인증 정보를 담당하는 서버이다.

MCMP를 사용하는 고객사는 발급된 계정 정보를 요청하여 JWT (Json Web Tocken)을 발급 받는데, 이때 이 토큰을 발급하고, 암호화하는 서버이다.

### 주요 역할

1. **토큰 요청** 고객사에서 요청한 토큰 요청에 JWT를 만들어 Response 한다.
2. **OIS 관리자 기능** 관리자의 권한 수정, 삭제,
3. **고객 정보 관련 api를 제공** (서비스 등록, 클라이언트, 정산코드) OIS의 고객 운영 관리 서비스 이다. 아래의 OIS 관련 자료를 참고하라.
4. **Agent Manager에서 적재한 Agent 모니터링 제공** Agent Manager의 모니터링도 아래의 OIS 관련 자료를 참고하라.

## 4. API Gate Way

MCMP의 입구 역할을 담당하는 서버이다.

MCMP에서 API Gateway의 역할은 **매우 중요하**다. API Gateway는 클라이언트와 마이크로서비스 간의 중간 계층 역할을 하여 요청을 라우팅, 보안, 모니터링 및 관리하는 데 사용된다.

### 주요 역할

- - **요청 라우팅 (Request Routing)** API Gateway는 클라이언트의 요청을 적절한 마이크로서비스로 라우팅한다. 이를 통해 클라이언트는 각 서비스의 세부 구현을 알 필요 없이 Gateway에 요청을 보낼 수 있다.
    - **부하 분산 (Load Balancing)** API Gateway는 여러 마이크로서비스 인스턴스 간에 요청을 분산시켜 부하를 고르게 분산시킨다.
    - **인증 및 권한 부여 (Authentication and Authorization)** 클라이언트 요청을 인증하고 권한을 부여하는 기능을 제공한다. 예를 들어, OAuth2, JWT 등을 사용하여 보안 계층을 구현할 수 있다.
    - **속도 제한 (Rate Limiting)**API Gateway는 특정 클라이언트가 주어진 시간 내에 보낼 수 있는 요청 수를 제한하여 서비스 남용을 방지할 수 있다.

## 5. Message Server

MCMP에 인입된 각 채널의 요청 메시지를 검증하고, 플랫폼 내부 프로토콜로 만드는 역할을 담당하는 비즈니스 로직을 갖춘 서버이다.

### 주요 역할

1. **중복 메시지키 검증**: Message Server에서는 Redis를 활용하여 MCMP에 인입된 Client의 요청 메시지키(SRC_MSG_ID)를 중복 검칙한다.
2. **선입금 검증** 선입금 업체의 경우 충전 금액을 모두 소진한 경우 플랫폼에서 실패할 수 있도록 차단한다.
3. **HDB에 인입 이력 적재** MCMP의 API를 거처 Message Server의 검칙에 성공한 경우 Router 서버로 보내기 전 처리 이력을 이력DB에 적재 한다.

## 6. PTP Server

MCMP에 인입된 메시지를 KISA의 SPAM 정책과, SD의 내부 정책에 따른 차단 기능을 수행하는 서버이다.

### **주요역할**

1. **광고 표기/미표기를 검증하여 차단한다**.
    - 문자 본문에 광고 표기 및 무료수신 거부 문자를 검칙한다.
2. **등록된 SPAM KEY WORD를 검증하여 차단한다.**
    - 운영자가 OIS (운영 관리 시스템) 페이지에서 등록한 SPAM 차단 KEY WORD를 차단한다
3. **KISA SPAM 정책을 검증하여 차단한다.**
    - 자세한 차단 정책은 PTP의 인수 인계 문서를 참고하자.
4. **SD의 내부 정책을 검증하여 차단한다.**
    - 자세한 차단 정책은 PTP의 인수 인계 문서를 참고하자.
5. **위의 정책들에 차단된 차단 리스트 UPDATE를 수행한다.**
    - 차단 정책으로 차단된 요청 리스트를 UPDATE 한다.

## 7. Router Server

MCMP에서 가장 핵심적인 기능을 담당하는 서버이다.

인입된 메시지를 차세대 Sender를 중계 해주는 역할을 수행한다.

**주요역할**

- - **PNX를 조회하여 해당 메시지의 통신사를 확인한다**
    - **설정된 라우팅 룰을 찾아온다**
    - **라우팅 룰에 부합하는 가용 가능한 센더를 찾는다**
    - **센더에 전송한다.**

## 8. Report Server

라우팅 서버가 라우팅한 메시지가 센더를 통해 처리된 이력을 고객사에 리포트 수행하는 서버이다.

**주요역할**

- - **결과 코드 converting**
    - **PORT OUT 체크**
    - **고객사에 WEB HOOK수행 :** 고객사에 push로 리포트 전달
    - **PNX 체크 :** PNX의 데이터를 UPDATE
    - **Logger에 이력 전달 :** MCMP가 처리한 이력을 HDB에 적재하여 저장한다.
    - **대체 전송 수행 :** RCS/KKO의 실패인 경우
    - **RCS FILE Report :** RCS로 등록된 File(ex 이미지)를 이통망에 등록하고 등록된 결과를 리포트 한다.

## 9. Retry Report Server

리포트 서버가 리포트 수행에 실패하여 재처리를 요할 경우 설정된 재처리 정책에 따라 리포트를 재 수행하는 서버이다.

**주요기능**

- - **리포트 재수행** 설정된 재처리 시도 횟수와, 시간에 따라 고객에게 리포트를 재처리 한다.
    - **고객사 리포트 수신 이력 Update** 리포트를 수신 받은 건을 DB Logger에게 전달한다.

## 10. DB Logger Server

MCMP에서 수행된 모든 Message의 처리 이력을 DB에 적재하는 서버이다.

**주요기능**

- - **이력 적재** Message Server에게 전달 받은 메시지 이력을 적재한다.
    - **재시도 성공시 Update** Retry Reporter가 고객사에 리포트 재시도 성공시 수신된 시각을 DB에 Update한다.
    - **이력 Update** Reporter 전달 받은 메시지를 적재한 이력에 UPDATE 수행한다.
    - **적재 실패시 재시도** DB Logger가 적재에 실패된 경우 DB에 적재 할 수 있을때까지 재시도한다.

## 11. Sender Manager Server

차세대 Sender와 주기적으로 Heart, Beat를 주고받으며 실시간으로 현재 Sender가 가용 가능한 상태인지 Router의 Sender 찾기 기능에서 활용될 status 필드를 업데이트 수행하여 플랫폼에서 발생한 Sender의 장애를 자동으로 복구한다.

**주요기능**

- - **Sender 가용성 check**
    - **Sender 장애시 적채된 Queue 재분배**
    - **수동으로 Message Queue를 옮기는 기능**

## 12. Agent Manager Server

Agent Manager는 차세대 플랫폼의 Agent(Client)의 부가 기능을 제공, 운영자가 Client를 관리 할 수 있는 기능을 제공한다.

**주요기능**

- - **Agent 모니터링 정보 수집** 차세대 Agent는 30초에 한번씩 메시지 전송량, 리포트 수신량, Agent버전에대한 정보를 서버에 전송한다.
    - **Agent의 미수신 리포트 요청 응답** 차세대 Agent는 발송한 이력을 하루 이상 수신 받지 못한 경우 미수신건을 요청하여 받아간다.

## 13. Data Manager Server

Data Manager는 MCMP에서 사용하는 정보를 등록, 수정, 삭제, 조회를 하는 기능을 제공하는 서버이다.

**주요기능**

- - Sender Info 관련 API 제공 : Sender Info를 등록, 수정, 삭제, 조회하는 기능을 제공한다
    - Route Info 관련 API 제공 : Route Info를 등록, 수정, 삭제, 조회하는 기능을 제공한다.

## 14. File Logger Server

File Logger Server는 MCMP에서 처리하던 이력 중 처리가 불가능할 때, 정형화 데이터로 만들 수 없을 때 등 이력을 파기할 수 없을 때, DB가 아닌 서버의 Disk에 file로 메시지를 적재하는 서버이다.

MCMP의 구성 Application의 개요, 대표적인 기능에 대해서 설명했다.

이외의 Application의 상세한 정보, 상세한 기능, 상세한 설정은 각 Applcation의 업무 기술서를 참고하길 바란다.

# 2. OIS에서의 플랫폼 운영 관리

MCMP는 운영자가 MCMP라는 거대한 대규모 분산 처리 시스템을 보다 효율적으로 운영할 수 있는 환경을 제공하고 싶었다. 그리고 MCMP가 운영이 됨에 따라, 운영자가 직접 보고 관리, 운영 할 수 있는 페이지의 필요성이 대두 되었다. 플랫폼을 운영 관리 할 수 있는 페이지를 만들었고, 만들어진 페이지가 바로 차세대 OIS이다.

OIS에서 담당하는 기능은 다음과 같다.

- OIS 담당 기능
	1. 고객 운영 관리
	2. Sender 운영 관리
	3. Routing 운영 관리
	4. Agent 모니터링

이 OIS에서 등록된 정보는 플랫폼이 메시지 요청을 처리하는데 판단하는 정책의 기반이 된다, 따라서 운영자는 기능에서 제공되는 기능이 어디서 어떤 역할을 수행하는지 정확하게 파악하고 있어야한다.

**MCMP의 운영 관리 페이지 사용법을 정확히 이해하지 못하고 사용하게 되면 발송이 대량 실패, 장애유발 등 플랫폼에 악영향을 끼칠 수 있다.**

자세히 들어가기 앞서, OIS에서 등록하는 **Sender 정보와 Router 정보는 DB와 Redis 모두 적재**되며, Router 프로세스가 **Routing 기능**을 수행하는데, 판단하는 **판단기준 데이터**가 된다.

다음은 OIS에서의 운영 관리를 어떻게 하는지, 설명 하겠다.

먼저, OIS의 고객 운영 관리에 대해서 설명하겠다.

OIS는 망분리가 되어 있다.

개발계: [http://220.95.214.16:443](http://220.95.214.16:443)

운영계: [http://222.233.53.42:443](http://222.233.53.42:443)

이렇게 2곳으로 접속 할 수 있다.

## OIS 개요

![[Eureka Health Check Image.png]]

### 구성 정보

| 서버명          | 개발계 (Staging)                                   | 운영계                                                       | 비고  |
| ------------ | ----------------------------------------------- | --------------------------------------------------------- | --- |
| OIS          | 220.95.214.16                                   | 222.233.53.42                                             |     |
| OAuth2       | 220.95.214.11                                   | 222.233.53.43                                             |     |
| API GW       | 220.95.214.12                                   | 222.233.53.36                                             |     |
| Data Manager | 220.95.214.11                                   | 222.233.53.37                                             |     |
| XDB          | 220.95.214.18                                   | 222.233.53.58                                             |     |
| Redis        | 220.95.214.5, 220.95.214.6,<br><br>220.95.214.7 | 222.233.53.25,<br><br>222.233.53.26,<br><br>222.233.53.27 |     |

(구성 정보는 추후에 바뀔 수 있으므로 버전 Update시 반드시 기입해주길 바란다.)

먼저, OIS에서 고객을 등록하는 방법을 설명하겠다.

회원의 정보의 경우 OAuth2 Server가 처리하여 XDB와 Redis 에 적재된다. 자세한 정보는 OAuth2 Server의 인수인계 문서를 참고하자.

![[OIS 고객 등록 이미지.png]]

고객란의 고객 조회 버튼을 눌러보면 해당 페이지를 통해 차세대에 현재 등록되어 있는 고객사를 알 수 있다.

## 고객 회원 가입

- 고객 회원 가입란 이미지
	![[고객 회원가입란 이미지.png]]

다음은 고객 회원 가입란이다. 아래와 같이 구성 되어 있다.

| 필드             | 설명                                             |
| -------------- | ---------------------------------------------- |
| 고객사 이름         | 고객사명                                           |
| 고객사 ID         | 고객이 사용할 ID                                     |
| 고객사 password   | 고객이 사용할 Password                               |
| password check | 고객이 사용할 Password확인                             |
| 그룹 코드          | 고객사에 부여할 Group Code(정산, 이력조회 등 여러 운영 요소에서 사용됨) |
| vasYn          | 고객사의 재판사 여부 (spma정책, oroginCode 정책 등에서 사용됨)    |

운영자는 위와 같이 고객이 발급할 정보를 보내주면 위의 내용을 작성하여 고객의 정보를 등록하면 된다.

- 고객 정보 리스트
	![[고객 정보 조회.png]]

고객을 가입 시켰다면 고객 리스트에서 고객의 상세보기의 Detail 버튼을 통해 아래의 페이지에 진입할 수 있다.
## 고객 정보 상세 조회

- 고객 상세 정보 페이지
	![[고객 상세 정보 조회.png]]


detail을 눌렀다면, 위와 같은 화면이 나온다. 고객사가 MCMP의 전송 서비스를 사용하려면

고객 서비스, 고객클라이언트, 고객 정상 코드를 모두 등록해야한다.

아래의 `+`버튼 을 차례대로 눌러보자

## 고객 서비스 추가

아래는 MCMP를 사용할 고객의 서비스를 추가하는 탭이다.

- 고객 서비스 추가
	![[고객 서비스 추가.png]]


| field          | value                          |
| -------------- | ------------------------------ |
| groupCode      | 고객사 그룹코드                       |
| smsUse         | sms 서비스 사용 유무                  |
| mmsUse         | mms 서비스 사용 유무                  |
| kmsUse         | 알림톡 서비스 사용 유무                  |
| rcsUse         | rcs 서비스 사용 유무                  |
| smsRequestTps  | SMS 발송 요청 TPS 제한 기능 (초당 허용 수)  |
| mmsRequestTps  | MMS 발송 요청 TPS 제한 기능 (초당 허용 수)  |
| rcsRequestTps  | RCS 발송 요청 TPS 제한 기능 (초당 허용 수)  |
| fileRequestTps | File 발송 요청 TPS 제한 기능 (초당 허용 수) |

이 페이지에서 등록한 서비스 사용 유무와 tps 제한 기능은 **OAuth2 Server**가 DB에 반영하고, 그정보를 MCMP의 **API G/W**가 조회하여 고객사의 발송요청을 제한한다.

운영적인 요소에서 앞단의 **request를 제한하는 기능을 제공하는 것이므로 설정할때 주의가 필요하다.**

## 고객 클라이언트 추가


아래는 고객이 사용할 클라이언트 키를 발급 받는 페이지이다.

- 고객 클라이언트 추가
	![[고객 클라이언트 추가.png]]


| field     | value                 |
| --------- | --------------------- |
| groupCode | 고객사의 식별 키             |
| reportUri | 고객의 클라이언트가 리포트를 받을 주소 |

고객의 groupCode와 고객이 **report를 받을 client의 주소**를 넣고 발급 받으면 고객의 클라이언트 키를 발급 받을 수 잇다.

간단하게 다뤘지만, 생각보다 중요하다 고객사의 report uri를 넣어야 하는데, 실존하지 않는 주소를 넣으면 리포트를 받을 수 없고, 이는 report 서버와 Retry Report 서버에 부하로 이어진다. 반드시 발급 후 운영전 사전 테스트를 시행할 것을 권장한다.

## 고객 정산 코드 추가


아래는 고객의 정산 코드를 추가하는 페이지이다. 고객사는 정산건을 여기서 발급받은 코드를 통해 나눌 수 있다.

- 고객사 정산 코드 추가 페이지
	![[고객 정산 코드 추가.png]]


| field     | value       |
| --------- | ----------- |
| groupCode | 그룹코드        |
| billCode  | 정산코드        |
| adFlag    | 광고 검칙 수행 여부 |

고객은 여기서 발급받은 정산코드를 통해 정산을 수행하게 된다. 사전에 발급받지 못한 정산 코드로 메시지 요청을 할 경우 실패된다.

- 고객 정보 확인
	![[고객 정보 확인.png]]

우리는 고객이 사용할 계정과 고객이 사용할 서비스, 고객의 클라이언트 발급, 고객이 사용할 정산코드도 발급 하였다, 이렇게 모든 고객의 정보를 발급받게 되면 고객이 MCMP를 사용할 준비는 완료 된것 같다.

하지만, 이렇게 발급된 고객을 어디로 어떻게 보내겠다는 정의하지 않았다. 라우팅 방법은 아래 3-3을 참고하자.

## Sender 운영 관리

MCMP를 포함한 Standard Networks의 문자 전송 시스템의 목적은 고객사로부터 받은 메시지 요청을 고객사가 보내야 할 목적지에 전달하는 전달자의 역할을 수행하는 것 이다, 따라서 Sender는 플랫폼을 운영하는 운영자에겐 매우 중요한 자원이다.

Standard Networks는 SMS Sender의 갯수가 약 100여개 MMS Sneder는 중계망까지 100여개 KKO Sender의 종류만 3개 이상 RCS Sender에 국제 발송 Sender까지 포함하면 그 종류가 수십 가지에 이른다. 따라서 플랫폼을 운영하는 운영자는 Sender가 어느 위치에 존재하는지, 또 현재 사용이 가능한 상태인지 알 필요가 있다.

Sender의 운영 정보가 어디에 어떻게 적재되고 어떻게 흐르는지는 위의 구성표를 보고 파악하길 바라고, 상세한 프로세스는 각 파트의 프로세스 업무 기술서를 보길 바란다.

OIS에서 Sender의 정보는 차세대 XDB의 Sender Info 테이블에 적재되고, Sender의 DB정보를 Redis에 같이 담는다.

OIS는 운영자에게 플랫폼에 할당된 Sender의 정보를 보다 편하게 접근 할 수 있도록 하였다.

### Sender 조회

![[센더 조회.png]]

Sender 가 등록된 DB 정보이다.

등록된 모든 센더가 조회되며 Sender 이름으로만, 지원하는 이통망, Sender Group, nation code로도 분류를 검색 할 수 있다.

### Sender 등록


- Sender 등록 화면
	![[센더 등록.png]]



| field          | value                                                  |
| -------------- | ------------------------------------------------------ |
| senderName     | 등록할 Sender의 이름                                         |
| exchange       | Sender가 사용할 exchange 이름                                |
| queueName      | Sender가 사용할 queue 이름                                   |
| natCd          | 센더의 국가 코드                                              |
| senderGroup    | Sender Group 이름 (라우팅에 사용되는 중요한 키, Redis의 Table 이름이 된다) |
| provider       | 지원하는 이통사                                               |
| messageChannel | Sender가 지원하는 Message channel                           |
| abillity       | Sender의 가용상태                                           |
| address        | Sender의 위치                                             |
| directory      | Sender의 위치                                             |
| createTime     | 등록된 시간                                                 |
| updateTime     | 수정된 시간                                                 |
| expireTime     | 만료처리 시간                                                |
| creator        | 등록자, 수정자                                               |
| rmk            | 센더의 부가 정보                                              |

Redis에 적재 되는 Sender의 정보

| field           | value                   |
| --------------- | ----------------------- |
| senderName      | 센더의 이름                  |
| senderQueueName | 센더가 소비할 queueName       |
| exchange        | 센더가 소비할 queue의 Exchange |
| senderGroup     | 센더가 속한 Group            |
| natCode         | 국가번호                    |
| provideList     | 지원하는 통신사 리스트            |
| messageChannel  | 센더가 지원하는 메시지 채널         |
| ability         | 센더의 가용상태                |

### Sender Name Rule

센더의 네이밍엔 룰이 존재한다.

아래의 예제를 보자.

- 센더 예시
	![[센더 명명 규칙.png]]

해당 사진은 운영기에 등록된 센더의 Rabbitmq 모니터링 현황이다.

해당 센더의 Queue 이름은 mt.sender.G_S_KT01이라는 이름으로 등록 되어 있다.

센더 네이밍 규칙은 먼저 “**IDC 존재의 위치 + _ + 센더의 지원 채널 + _ + 센더의 타겟**”이다.

즉, **G_S_KT01은 G는 강남을 뜻하고 S는 SMS를 뜻한다. 뒤의 KT01은 KT의 01번째 Sender 라는 의미**이다.

이렇게 우리는 Sender의 queue이름만으로도 우리는 해당 센더가 어디에 존재하고 어떤 채널을 담당하는 센더인지 알 수 있다.

## Routing 운영 관리

**Routing** 이란 경로를 배정, 경로를 제어하는 기능을 뜻한다.

MCMP에서 라우팅은 가장 중요한 기능이다. 우리는 이 기능을 통해 특정 고객의 물량을 특정 이통망으로 전송 할 수 있다. 이 기능은 특별한 기능들을 포함해서 가장 플랫폼에서 중요도가 높은 기능이다,

처음 플랫폼을 운영하는 운영자가 가장 이해하기 어려운 기능이라고 생각한다. 숙련된 운영자더라도 관리자 혹은 개발팀과 충분한 상의 후 지정을 하면 좋겠다.

앞서 우리는 고객을 등록했고, MCMP에서 가용될 Sender를 등록하는 방법도 배웠다. 이번엔 등록된 고객이 전송한 물량을 우리가 등록한 센더에 라우팅을 해보자.

### 라우팅 조회

![[라우팅 조회.png]]
조회된 페이지를 보면 현재 MCMP에 등록되어 있는 모든 라우팅 정보를 조회 할 수 있다.

| field      | value                                        |
| ---------- | -------------------------------------------- |
| routeId    | groupCode + _ + channel 의 값으로 라우팅 정보의 식별키이다. |
| groupCode  | 고객사 식별 코드                                    |
| channel    | 고객사의 메시지 채널                                  |
| skt        | 고객사 식별 코드의 메시지 채널의 skt 물량을 어떻게 처리할지 적는다.     |
| kt         | 고객사 식별 코드의 메시지 채널의 kt 물량을 어떻게 처리할지 적는다.      |
| lgt        | 고객사 식별 코드의 메시지 채널의 lg 물량을 어떻게 처리할지 적는다.      |
| kko        | 고객사 식별 코드의 KKO 물량을 어떻게 처리할지 적는다.             |
| createTime | 등록된 시간                                       |
| updateTime | 수정한 시간                                       |
| creator    | 수정자                                          |
| rmk        | remark                                       |

먼저 조회된 테이블의 결과의 Route Id는 라우팅을 지정하는 **식별키로** 삼는 값이다, 사용자가 지정할 필요 없이 자동으로 셋팅 된다.

중요한 것은 식별키 이기 때문에 반드시 식별키 이기 때문에 **Unique** 하다.

쉽게 말해서 한 업체의 특정 메시지 채널의 라우팅 룰은 하나만 등록이 가능하다는 소리이다.

나머지 필드에 대해서는 라우팅을 등록하는 부분과 그 이후에 설명을 이어서 하겠다.

### 라우팅 등록

![[라우팅 등록.png]]

라우팅 등록을 하는 페이지이다.

그룹 코드와 채널의 경우 위에서 설명을 했기 때문에 SKT, KT, LGT, KKO에 대한 설명을 하겠다.

사진을 자세히 보면 Sender Group이라고 희미하게 글자가 보일 것이다.

그렇다, 우리는 위에서 Sender를 등록했고, Sender를 등록할때 Sender Group을 지정했다. 바로 그 Sender Group을 넣는것이다.

아래는 SKT, KT, LGT, KKO에 들어가는 SenderGroup의 정보이다.

| field        | value                     |
| ------------ | ------------------------- |
| Sender Group | 등록된 Sender의 그룹            |
| ratio        | 등록된 Sender의 그룹으로 라우팅이 될 비 |

아래의 사진을 보면

![[라우팅 룰 이미지1.png]]

이런식으로 특정 이동 통신사의 라우팅 룰을 추가할 수 있다. 이해가 되긴 하지만, 정확히 이해하기 어려우니 예시를 통해 이해해보자.

아래는 개발계 운영 관리 페이지의 한 예시이다.

![[라우팅 룰 이미지2.png]]

자세히보면 A000005라는 업체의 KKO 즉, 알림톡의 라우팅 설정이다.

KKO 필드의 데이터가

`[{"senderGroupName":"LDCC","ratio":1},{"senderGroupName":"LGCNS","ratio":0}]`

라고 설정 되어 있다.

이 이야기는 A000005라는 업체의 알림톡을 LDCC 1 : LGCNS 0의 비율로 전송하라는 의미이다.

이렇게 라우팅에 특정 Sender 그룹을 넣어도 ratio의 값을 0을 넣으면 그쪽으로 전송 되지 않게된다.

만약 ratio를 양쪽 LDCC 1: LGCNS1 이런 비율로 넣었다면 10건을 보냈을때 5 : 5로 전송될 것이다.

중요한것은 RATIO의 총 합이 100이 되지 않는다, 단지 존재하는 총 라우팅 룰의 Ratio 총합이 분모로 그 센더 그룹에 지정한 ratio가 분자로 그만큼 라우팅 되는 것을 의미한다.

# 모니터링 시스템

MCMP는 대규모 분산 시스템이기 때문에, 플랫폼 전체의 흐름과 퍼포먼스를 확인하기가 어려운 것은 사실이다, 이는 MSA 아키텍처의 문제점으로 꼽히는데, 이 문제를 조금이라도 개선하고자 네이버에서 사용하는 Pin Point를 설치하여 구성하였다.

### PinPoint

MSA 아키텍처에서 주로 사용하는 플랫폼을 모니터링 하기 위한 APM (Application Performance Monitoring) 도구이다. 내부적으로 서버맵, 실시간 활성 스레드 차트, 요청 / 응답 차트, API 호출 상세 기록, 서버의 상태를 실시간으로 시각화하여 볼 수 있는 기능을 제공하는 솔루션이다.

![[핀포인트 이미지.png]]

- Pinpoint Agent
    - 스프링부트와 같은 애플리케이션의 모니터링 정보(API 상세 호출 내역, 서버 CPU, 활성 스레드 개수 등)을 Collector에 전달
- Pinpoint Collector
    - Pinpoint Agent로부터 받은 데이터를 HBase에 적재
- Pinpoint Web
    - Hbase에 적재된 데이터를 Web으로 보여줌

### 구성 정보

| 서버명          | 개발계 (Staging) | 운영계                                                       | 비고  |
| ------------ | ------------- | --------------------------------------------------------- | --- |
| pint point   | 구성 안함         | 222.233.53.42                                             |     |
| hbase        | 구성 안함         | 222.233.53.43                                             |     |
|              | 구성 안함         | 222.233.53.36                                             |     |
| Data Manager | 구성 안함         | 222.233.53.37                                             |     |
| XDB          | 구성 안함         | 222.233.53.58                                             |     |
| Redis        | 구성 안함         | 222.233.53.25,<br><br>222.233.53.26,<br><br>222.233.53.27 |     |

### 설치 방법

1. Hbase 설치
    1. 아카이브의 Hbase tar 파일을 서버에서 설치
        1. wget [https://archive.apache.org/dist/hbase/1.2.7/hbase-1.2.7-bin.tar.gz](https://archive.apache.org/dist/hbase/1.2.7/hbase-1.2.7-bin.tar.gz)
    2. tar 파일 압축 해제
        1. tar xzvf hbase-1.2.7-bin.tar.gz
    3. start-hbase.sh로 실행

1. PintPoint 테이블 생성
    1. 테이블 정보 다운로드
        1. wget [https://raw.githubusercontent.com/pinpoint-apm/pinpoint/master/hbase/scripts/hbase-create.hbase](https://raw.githubusercontent.com/pinpoint-apm/pinpoint/master/hbase/scripts/hbase-create.hbase)
    2. 스크립트 실행 ex)/svc에서 수행
        1. hbase/bin/hbase shell ../hbase-create.hbase
        2. ./hbase shell ../../hbase-create.hbase
2. PinPoint Collector 설치 (프로젝트의 jdk가 17이여서 2.5.3버전을 채택함)
    1. collector 설치
        1. wget [https://github.com/pinpoint-apm/pinpoint/releases/download/v2.5.3/pinpoint-collector-boot-2.5.3.jar](https://github.com/pinpoint-apm/pinpoint/releases/download/v2.5.3/pinpoint-collector-boot-2.5.3.jar)
    2. collector 실행
        1. nohup java -jar -Dpinpoint.zookeeper.address=localhost pinpoint-collector-boot-2.2.2.jar >/dev/null 2>&1 &
3. PinPoint Web 설치
    1. web 설치
        1. wget [https://github.com/pinpoint-apm/pinpoint/releases/download/v2.5.3/pinpoint-web-boot-2.5.3jar](https://github.com/pinpoint-apm/pinpoint/releases/download/v2.5.3/pinpoint-web-boot-2.5.3jar)
    2. web 실행
        1. nohup java -jar -Dpinpoint.zookeeper.address=localhost pinpoint-web-boot-2.2.2.jar >/dev/null 2>&1 &
4. PinPoint Agent 구성
    1. Agent 설치
        1. wget [https://github.com/pinpoint-apm/pinpoint/releases/download/v2.5.3/pinpoint-agent-2.5.3.tar.gz](https://github.com/pinpoint-apm/pinpoint/releases/download/v2.5.3/pinpoint-agent-2.5.3.tar.gz)
    2. tar 해제
        1. tar xvzf pinpoint-agent-2.2.2.tar.gz
    3. config 파일 수정 기존 monitoring ec2 ip 수정
        1. vi pinpoint-root.config
        2. → profiler.transport.grpc.collector.ip=pinpoint ip로 변경
5. Application 실행 script 추가
    1. [start.sh](http://start.sh/) Agent 실행문구 추가
        1. javaagent:/svc/pinpoint-agent-2.5.3/pinpoint-bootstrap.jar -Dpinpoint.agentId=rpt-agent -Dpinpoint.applicationName=Reporter -Dpinpoint.config=./pinpoint-agent-2.5.3/pinpoint-root.config
6. 결과

PinPoint 추적 server map dash 보드

![[핀 포인트 서비스 맵.png]]

APM 적용 후 플랫폼 모니터링

![[APM 적용 모니터링 이미지1.png]]

![[APM 적용 모니터링 이미지2.png]]

![[APM 적용 모니터링 이미지3.png]]

![[APM 적용 모니터링 이미지4.png]]

![[APM 적용 모니터링 이미지5.png]]

![[APM 적용 모니터링 이미지6.png]]